# ASCII Art

Первая часть кода осталась без изменений с заготовки.

`transform(t.begin(), t.end(), t.begin(), ::toupper);` Из условия мне не было понятно, всегда ли у нас символы в одном регистре, поэтому во избежание проблем я решила все привести к заглавному виду.

``` C++
vector<string> rows(h);
    for (int i = 0; i < h; i++) {
        getline(cin, rows[i]);
    }
```

Здесь я для удобства работы и хранения поменяла строку на коллекцию.

В оставшемся цикле мы занимаемся преобразованием введенного текста в ASCII Art. Поскольку позиция буквы в ASCII алфавите совпадает с обычным алфавитом, плюс вопросительный знак, мы легко можем провести сопоставление. Далее в конце цикла выводится полученный результат.

# Button Mash

Первая часть кода осталась без изменений с заготовки.

` const int MAX = 2 * n + 2;`  Чтобы не уйти слишком далеко, но рассмотреть случаи, когда мы превышаем, но можем вернуться обратно, чтобы получить нужное число, ввожу число MAX.

Дальше идет реализация поиска в ширину. Мы создаем очередь, куда кладем пару (0, 0) - ноль получили, ноль шагов сделали. Мы сравниваем первое число с n и, если они не совпали, начинаем преобразования. Также мы используем visited, чтобы не обрабатывать одно и то же несколько раз.

В конце мы получаем нужное число и выводим количество шагов на экран.

# Cheap Choices

Первая часть кода без изменений.

``` C++
vector<string> items;
    for (int i = 0; i < c; i++) {
        string item;
        getline(cin, item);
        items.push_back(item);
    }
```
Тут мы считываем товары и сохраняем их в список.

Далее мы начинаем работать с каждым заказом. 

``` C++
string order;
getline(cin, order);
istringstream iss(order);
string reqCategory, reqSize;
iss >> reqCategory >> reqSize;
```

Тут мы читаем заказ и распределяем его элементы по типу заказа и его размеру.

`if (items[j] == "") continue;` Если пустота, то значит уже нет этой вещи, её продали, т.е. рассматривать случай не нужно.

``` C++
istringstream itemStream(items[j]);
string category, size;
int price;
itemStream >> category >> size >> price;
```

Делим ранее считавшуюся строку на параметры.

``` C++
if (category == reqCategory && size == reqSize) {
    if (minPrice == -1 || price < minPrice) {
        minPrice = price;
        minIndex = j;
    }
}
```

Тут мы смотрим, есть ли вещь в нужном нам размере, а также проверяем цену, чтобы предложить минимальную среди аналогов, если они есть.

``` C++
if (minIndex == -1) {
            cout << "NONE" << endl;
        } else {
            cout << minPrice << endl;
            items[minIndex] = ""; 
        }
```

Тут выводим "NONE", если нужной вещи нет, а, если есть, то - цену, так же делаем строку о данных вещи пустой, чтобы пометить как проданную.

# Container Terminal

Первая часть кода идет из заготовки.

Сам поиск в задаче идет через жадный алгоритм.

`vector<char> stacks;` Создаем stacks, где будем хранить верхушки стопок.

`bool placed = false;` Тут мы говорим, что в существующих стопках места нет. 

Далее мы идем по элементам массива верхушек. Если нашли место, то `placed = True`, иначе в существующих стопках места нет, и в `stacks.push_back(c);` мы делаем новую стопку для контейнера.

В конце выводим количество стопок.

# The Descent

Цикл и считывание высоты остались с заготовки.

``` C++
int target_h = -1;
int target_ind = 0;
```
Чтобы ничего не упустить, высоту делаем настолько низко, что ввести ниже не получится, а индекс по умолчанию будет "0".

``` C++
if (mountain_h > target_h) {
    target_h = mountain_h;
    target_ind = i;
}
```
Считываем высоту горы и сравниваем с максимальным значением на данный момент, если она выше, сама становится максимальной, её индекс запоминается.

В конце выводим индекс цели.

# Don't Panic - Episode 1

Часть считывания элементов была визуально изменена для удобства восприятия.

`unordered_map<int,int> elevatorPos;` Создаем словарь, этаж - позиция лифта. В цикле заполняем этот словарь.

``` C++
while (1) {
    int clone_floor, clone_pos;
    string direction;
    cin >> clone_floor >> clone_pos >> direction; cin.ignore();

    if (clone_floor == -1) {
    cout << "WAIT" << endl;
    continue;
    }
```
Тут считываем этаж и позицию клона, иначе ждем его появления.

``` C++
int target;
if (clone_floor == exit_floor) target = exit_pos;
else target = elevatorPos[clone_floor];
```

Если мы на этаже с выходом, то идем на выход, иначе нам нужен лифт.

``` C++
if ((direction == "RIGHT" && clone_pos > target) ||
    (direction == "LEFT"  && clone_pos < target)) {
    cout << "BLOCK" << endl;
} else {
    cout << "WAIT" << endl;
}
```
Тут проверяем, идёт ли клон в нужном направлении, иначе нам надо заблокировать ему путь, чтобы он развернулся.

# Ghost Legs

Первая часть кода остается из заготовки.

`vector<string> diagram;` Создаем место для хранения строк диаграмм.

``` C++
 string topLine = diagram[0];
    vector<char> topLabels;
    for (int i = 0; i < topLine.length(); i++) {
        if (topLine[i] != ' ') {
            topLabels.push_back(topLine[i]);
        }
    }
    
    string bottomLine = diagram[h-1];
    vector<char> bottomLabels;
    for (int i = 0; i < bottomLine.length(); i++) {
        if (bottomLine[i] != ' ') {
            bottomLabels.push_back(bottomLine[i]);
        }
    }
```

Нам не нужны пробелы в этих местах, поэтому было решено убрать их для удобства.

``` C++
for (int topIndex = 0; topIndex < topLabels.size(); topIndex++) {
    int currentCol = topIndex * 3; 
    int currentRow = 1;
    
    while (currentRow < h - 1) {
        if (currentCol > 0 && diagram[currentRow][currentCol - 1] == '-') {
            currentCol -= 3;
        }
        else if (currentCol < w - 1 && diagram[currentRow][currentCol + 1] == '-') {
            currentCol += 3;
        }
        currentRow++;
    }
}
```

Дальше мы анализируем диаграмму. Производим умножение на три, т.к. это длина колонки. Далее мы проверяем, есть ли перегородки. В случае, если нет, просто идем дальше.

``` C++
int bottomIndex = currentCol / 3;
cout << topLabels[topIndex] << bottomLabels[bottomIndex] << endl;
```

Далее смотрим, где мы оказались. Т.к. мы убрали пробелы в верхней и нижней строчках, то делим currentCol на три и выводим пару.

# Rectangle Partition

Первая часть без изменений.

``` C++
vector<int> X(count_x + 2), Y(count_y + 2);
X[0] = 0;
for (int i = 1; i <= count_x; i++) cin >> X[i];
X[count_x + 1] = w;
Y[0] = 0;
for (int i = 1; i <= count_y; i++) cin >> Y[i];
Y[count_y + 1] = h;
```

Тут мы создаем два массива для хранения отметок. Берем значение с + 2, т.к. левая граница + count отметок + правая граница = 1 + count_ + 1 = count_ + 2.

``` C++
int maxLen = max(w, h);
vector<long long> freqX(maxLen + 1, 0), freqY(maxLen + 1, 0);
```

Мы создаём списки, куда в последующих двух циклах добавим количество всевозможных отрезков.

Далее мы считаем количество квадратов каждого размера и выводим результат.

# Stock Exchange Losses

``` C++
int n;
cin >> n; 
cin.ignore();
vector<int> values(n);
for (int i = 0; i < n; i++) {
    cin >> values[i];
}
```

Сначала мы считываем количество акций, а затем в список считываем их цены.

Далее мы объявляем переменную с максимальной ценой и максимальной потерей.

``` C++
for (int i = 1; i < n; i++) {
    int currentLoss = values[i] - maxSoFar;
    maxLoss = min(maxLoss, currentLoss); 
    maxSoFar = max(maxSoFar, values[i]); 
}
```

Далее, начиная со второго элемента, мы ищем максимальную потерю и максимальную стоимость на рассматриваемый момент.

В конце мы выводим результат.

# Temperatures

Сначала мы читаем количество показаний и, если их нет, выводим 0.

Далее мы вводим переменную closest, которую приравниваем к первому значению.

``` C++
for (int i = 1; i < n; i++) {
    int t;
    cin >> t;

    if (abs(t) < abs(closest) || (abs(t) == abs(closest) && t > closest)) {
        closest = t;
    }
}
```

Далее мы сравниваем новые показания, записывая в closest либо наименьшее показание, либо, если два равно по модулю, то, которое положительно.

В конце выводим результат.

# There is no Spoon - Episode 1

Сначала мы считываем размеры сетки, а затем в первом цикле её содержание.

``` C++
for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
        if (grid[y][x] == '0') {
            int x2 = -1, y2 = -1;
            int x3 = -1, y3 = -1;
```
Мы идем по всем x и y и если находим не ".", а "0", то начинаем проверять. Объявляем координаты соседей и даем им значение "-1" на случай, если ничего не найдем.

В первом цикле мы ищем соседа справа, поэтому проходимся по координате x, а во втором ищем снизу и смотрим y.

В конце выводим результат.

# Roman Sorting

В первых строчках мы считываем количество цифр и создаем два массива: с римской записью чисел и с арабской.

``` C++
    for (int i = 0; i < n; i++) {
        cin >> nums[i];

        int x = nums[i];
        string s = "";

        while (x >= 1000) { s += "M"; x -= 1000; }
        if (x >= 900) { s += "CM"; x -= 900; }
        if (x >= 500) { s += "D"; x -= 500; }
        if (x >= 400) { s += "CD"; x -= 400; }
        while (x >= 100) { s += "C"; x -= 100; }
        if (x >= 90) { s += "XC"; x -= 90; }
        if (x >= 50) { s += "L"; x -= 50; }
        if (x >= 40) { s += "XL"; x -= 40; }
        while (x >= 10) { s += "X"; x -= 10; }
        if (x == 9) { s += "IX"; x -= 9; }
        if (x >= 5) { s += "V"; x -= 5; }
        if (x == 4) { s += "IV"; x -= 4; }
        while (x >= 1) { s += "I"; x -= 1; }

        roman[i] = s;
    }
```
Здесь мы считываем число, создаем его копию и преобразуем её в римское число, добавляя потом в список с римской записью под тем же индексом, что и изначальное число.

``` C++
    for (int i = 0; i < n-1; i++) {
        for (int j = i+1; j < n; j++) {
            if (roman[i] > roman[j]) {
                string tempS = roman[i];
                roman[i] = roman[j];
                roman[j] = tempS;

                int tempN = nums[i];
                nums[i] = nums[j];
                nums[j] = tempN;
            }
        }
    }
```
Далее через сортировку пузырьком распределяем места, а затем меняем их в массиве с числами в арабской записи.

В конце выводим результат.
